# 1. 정수형
a = 1000  #양의 정수
print(a)

a = -7
print(a)

# 0
a = 0
print(a)

# --------------------------------------------------
# 2. 실수형

# 양의 실수
a = 157.93;
print(a)

# 음의 실수
a = -1837.2
print(a)

# 소수부가 0일 때 0을 생략
a= 5.
print(a)

# 정수부가 0일 때  0을 생략
a= -.7
print(a)

# --------------------------------------------------
# 3. 지수표현방식
# 유효숫자e^지수 = 유효숫자X10^지수
a = 1e9 #10의 9제곱 -> 10억
print(a)

# 752.5
a = 75.25e1 # 75.25*10^1 -> 752.5
print(a)

#3.954
a= 3954e-3 # 3954*10^-3 -> 3.954
print(a)

# 보통 컴퓨터 시스템은 수 데이터를 처리할 때 2진수를 이용하며, 실수를 처리할 떄 부동 소수점
# 방식을 이용한다. 오늘날 가장 널리 쓰이는 IEEE754 표준에서는 실수형을 저장하기 위해 4바이트,
# 혹은 8바이트라는 고정된 크기의 메모리를 할당하며, 이러한 이유로 인해 현대 컴퓨터 시스템은
# 대체로 실수 정보를 표현하는 정확도에 한계를 가진다.
# 예를들어 10진수 체계에서는 0.3과 0.6을 더한 값이 0.9로 정확히 떨어지지만, 2진수에서는
# 0.9를 정확히 표현할 수 있는 방법이 없다. 물론 최대한 0.9와 가깝게 표현하지만 표현한 값이 정확히
# 0.9가 아닌 미세한 오차가 발생한다. 일반적으로 코딩 테스트 문제를 풀기 위해서 컴퓨터의 내부 동작
# 방식까지 자세히 알 필요는 없으나 컴퓨터가 실수를 정확히 표현하지 못한다는 사실은 기억하자.

a = 0.3 + 0.6
print(a) # ->0.8999999999999999

if a==0.9 :
    print(True)
else :
    print(False)
#False 출력!

# 따라서 소수점 값을 비교하는 작업이 필요한 문제라면 실수 값을 비교하지 못해서 원하는 결과를 얻지 못할 수 있다.
# -> round()함수 이용하면 해결가능!
# round() : 반올림 함수
# 첫번째 인자 : 실수형 데이터
# 두번째 인자 : 반올림하고하자는 위치 -1

a = 0.3 + 0.6
print(a) # ->0.8999999999999999

# 일반적으로 코딩테스트 문제에서 실수형 데이터를 비교할 때 소수점 다섯 번째 자리에서 반올림한 결과가 같으면 정답이다.
if round(a,4)==0.9 : # 0.8999999999999999를 소숫점 5번째 자리에서 반올림
    print(True)
else :
    print(False)
# True출력
